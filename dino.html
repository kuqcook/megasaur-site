<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MEGASaur Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }

    h1 {
      margin-top: 20px;
      font-size: 2rem;
      text-shadow: 2px 2px #00f0ff;
    }

    .container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
      max-width: 1600px;
      width: 100%;
    }

    canvas {
      background: rgba(0, 0, 0, 0.5);
      border: 4px solid #00f0ff;
      border-radius: 16px;
      margin: 20px;
      flex-grow: 1;
      image-rendering: pixelated;
    }

    #leaderboard {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 16px;
      margin: 20px;
      width: 260px;
      box-shadow: 0 0 10px #00f0ff;
    }

    #leaderboard h2 {
      margin-bottom: 10px;
      font-size: 1.3rem;
    }

    ol#scores {
      padding-left: 20px;
    }

    ol#scores li {
      font-size: 1rem;
      color: #00f0ff;
    }

    #touch-btn {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 1rem;
      font-size: 1.5rem;
      font-weight: bold;
      background: #00f0ff;
      color: #000;
      border: none;
      border-top: 2px solid #fff;
      z-index: 10;
    }

    @media (pointer: coarse) {
      #touch-btn {
        display: block;
      }
    }

    #nickname-form, #game-over {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
      transition: opacity 0.5s ease-in-out;
    }

    #nickname-form input, #game-over button {
      padding: 8px;
      font-size: 1rem;
      margin-top: 8px;
    }

    #nickname-form button, #game-over button {
      padding: 8px 16px;
      margin-top: 8px;
      font-size: 1rem;
      background: #00f0ff;
      color: black;
      border: none;
      cursor: pointer;
    }

    #game-over.show {
      display: flex;
      opacity: 1;
    }

    #game-over {
      opacity: 0;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
    }

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
        align-items: center;
      }

      canvas {
        width: 100% !important;
      }
    }
  </style>
</head>
<body>
  <h1>ü¶ñ MEGASaur Runner</h1>

  <div id="nickname-form">
    <label for="nickname">Enter your nickname:</label>
    <input type="text" id="nickname" placeholder="e.g. DinoMaster" maxlength="20" />
    <button onclick="startGame()">Start Game</button>
  </div>

  <div id="game-over">
    <h2>Game Over!</h2>
    <p id="final-score"></p>
    <button onclick="restartGame()">Play Again</button>
  </div>

  <div class="container">
    <canvas id="game"></canvas>

    <div id="leaderboard">
      <h2>üèÜ Top 10 Dino Tamers</h2>
      <ol id="scores"></ol>
    </div>
  </div>

  <button id="touch-btn">TAP TO JUMP</button>

  <script type="module">
    // Import Firebase modular SDK
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import { getDatabase, ref, push, onValue, query, orderByChild, limitToLast } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';

    // Initialize Firebase
    let database;
    try {
      const firebaseConfig = {
        apiKey: "AIzaSyACFWv9js50STTex2TzTjEubBP_3heZXgc",
        authDomain: "megasaur-runner.firebaseapp.com",
        databaseURL: "https://megasaur-runner-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "megasaur-runner",
        storageBucket: "megasaur-runner.firebasestorage.app",
        messagingSenderId: "222910326781",
        appId: "1:222910326781:web:b92195977fda4af2661b94"
      };
      const app = initializeApp(firebaseConfig);
      database = getDatabase(app);
      console.log("Firebase initialized successfully");
    } catch (error) {
      console.error("Firebase initialization error:", error.message, error.stack);
      document.getElementById("scores").innerHTML = `<li>Failed to connect to leaderboard: ${error.message}</li>`;
    }

    // Initialize canvas
    const canvas = document.getElementById("game");
    let ctx;
    if (canvas) {
      ctx = canvas.getContext("2d");
    } else {
      console.error("Canvas element not found");
    }

    // Resize canvas dynamically
    function resizeCanvas() {
      if (!canvas) return;
      const maxWidth = window.innerWidth > 768 ? 1400 : window.innerWidth - 40;
      canvas.width = maxWidth;
      canvas.height = maxWidth / (1400 / 250);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const dino = {
      x: 50,
      y: 230,
      vy: 0,
      width: 40,
      height: 40,
      jumping: false,
      jumpCooldown: 0,
      frame: 0,
    };

    const gravity = 0.5;
    let obstacles = [];
    let powerUps = [];
    let score = 0;
    let gameSpeed = 6;
    let gameOver = false;
    let nickname = "";
    let hasShield = false;
    let lastFrameTime = performance.now();
    let lastObstacleSpawn = 0;
    let animationFrameId;
    let backgroundObjects = canvas ? [
      { x: canvas.width, y: 50, emoji: "üåô", size: 30 },
      { x: canvas.width + 300, y: 80, emoji: "‚≠ê", size: 20 },
      { x: canvas.width + 600, y: 60, emoji: "‚≠ê", size: 25 },
      { x: canvas.width + 900, y: 70, emoji: "üåô", size: 35 },
    ] : [];

    const obstacleTypes = [
      { type: "gate", emoji: "‚õ©Ô∏è", width: 40, height: 40, y: 230 },
      { type: "pterodactyl", emoji: "ü¶Ö", width: 60, height: 30, y: 140 },
    ];

    const powerUpTypes = [
      { type: "shield", emoji: "üõ°Ô∏è", width: 30, height: 30, y: 230 },
    ];

    function spawnObstacle(timestamp) {
      if (obstacles.length < 2 && timestamp - lastObstacleSpawn > 1000) {
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacles.push({
          x: canvas ? canvas.width + 100 + Math.random() * 300 : 100 + Math.random() * 300,
          y: type.y,
          width: type.width,
          height: type.height,
          type: type.type,
          emoji: type.emoji,
        });
        lastObstacleSpawn = timestamp;
      }
    }

    function spawnPowerUp() {
      if (powerUps.length < 1 && Math.random() < 0.005) {
        const type = powerUpTypes[0];
        powerUps.push({
          x: canvas ? canvas.width + 100 + Math.random() * 300 : 100 + Math.random() * 300,
          y: type.y,
          width: type.width,
          height: type.height,
          type: type.type,
          emoji: type.emoji,
        });
      }
    }

    function draw() {
      if (!ctx || !canvas) {
        console.error("Cannot draw: Canvas or context not available");
        return;
      }
      try {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background (moons and stars)
        ctx.font = "30px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        backgroundObjects.forEach((obj) => {
          ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          ctx.font = `${obj.size}px serif`;
          ctx.fillText(obj.emoji, obj.x, obj.y);
        });

        // Draw ground with emoji
        ctx.font = "20px serif";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        for (let x = 0; x < canvas.width; x += 15) {
          ctx.fillStyle = "#8B4513";
          ctx.fillText("üü´", x, canvas.height - 5);
        }

        // Draw dino
        ctx.save();
        ctx.translate(dino.x + dino.width / 2, dino.y);
        ctx.scale(-1, 1);
        ctx.font = "32px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        const dinoEmoji = dino.jumping ? "ü¶ñ" : ["ü¶ñ", "ü¶ï"][Math.floor(dino.frame / 10) % 2];
        ctx.fillStyle = hasShield ? `hsl(${Date.now() % 360}, 100%, 50%)` : "white";
        ctx.fillText(dinoEmoji, 0, 0);
        ctx.restore();

        // Draw obstacles
        obstacles.forEach((obstacle) => {
          ctx.font = obstacle.type === "pterodactyl" ? "30px serif" : "40px serif";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "white";
          ctx.fillText(obstacle.emoji, obstacle.x, obstacle.y);
        });

        // Draw power-ups
        powerUps.forEach((powerUp) => {
          ctx.font = "30px serif";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "yellow";
          ctx.fillText(powerUp.emoji, powerUp.x, powerUp.y);
        });

        // Draw score and shield status
        ctx.fillStyle = "#00f0ff";
        ctx.font = "20px monospace";
        ctx.fillText(`Score: ${score}`, 10, 30);
        if (hasShield) {
          ctx.fillText("üõ°Ô∏è Shield Active!", 10, 60);
        }
      } catch (error) {
        console.error("Error in draw function:", error);
      }
    }

    function update(deltaTime, timestamp) {
      if (gameOver) return;

      const dt = deltaTime / 16.67;

      // Update dino
      dino.y += dino.vy * dt;
      dino.vy += gravity * dt;

      if (canvas && dino.y > canvas.height - 20) {
        dino.y = canvas.height - 20;
        dino.vy = 0;
        dino.jumping = false;
      }

      // Update run animation
      dino.frame += dt;
      if (dino.frame > 20) dino.frame = 0;

      // Update background objects
      backgroundObjects.forEach((obj) => {
        obj.x -= 0.5 * dt;
        if (canvas && obj.x < -obj.size) {
          obj.x = canvas.width + obj.size;
        }
      });

      // Update obstacles
      obstacles.forEach((obstacle, index) => {
        obstacle.x -= gameSpeed * dt;
        if (canvas && obstacle.x < -obstacle.width) {
          obstacles.splice(index, 1);
          score++;
        }
      });

      // Update power-ups
      powerUps.forEach((powerUp, index) => {
        powerUp.x -= gameSpeed * dt;
        if (canvas && powerUp.x < -powerUp.width) {
          powerUps.splice(index, 1);
        }
      });

      // Spawn new obstacles
      spawnObstacle(timestamp);

      // Spawn power-ups
      spawnPowerUp();

      // Increase game speed
      gameSpeed = 6 + score / 300;

      // Update jump cooldown
      if (dino.jumpCooldown > 0) {
        dino.jumpCooldown -= dt;
      }

      // Collision detection
      for (let obstacle of obstacles) {
        const dinoHitbox = {
          x: dino.x + 5,
          y: dino.y + 5,
          width: dino.width - 10,
          height: dino.height - 10,
        };
        const obstacleHitbox = {
          x: obstacle.x + 5,
          y: obstacle.y + 5,
          width: obstacle.width - 10,
          height: obstacle.height - 10,
        };

        if (
          dinoHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
          dinoHitbox.x + dinoHitbox.width > obstacleHitbox.x &&
          dinoHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
          dinoHitbox.y + dinoHitbox.height > obstacleHitbox.y
        ) {
          if (hasShield) {
            hasShield = false;
            obstacles.splice(obstacles.indexOf(obstacle), 1);
          } else {
            gameOver = true;
            saveScore(score, nickname);
            document.getElementById("final-score").textContent = `Final Score: ${score}`;
            document.getElementById("game-over").classList.add("show");
            document.getElementById("touch-btn").style.display = "none";
          }
        }
      }

      // Power-up collision
      for (let powerUp of powerUps) {
        if (
          dino.x < powerUp.x + powerUp.width &&
          dino.x + dino.width > powerUp.x &&
          dino.y < powerUp.y + powerUp.height &&
          dino.y + dino.height > powerUp.y
        ) {
          if (powerUp.type === "shield") {
            hasShield = true;
            powerUps.splice(powerUps.indexOf(powerUp), 1);
          }
        }
      }
    }

    function jump() {
      if (!dino.jumping && dino.jumpCooldown <= 0) {
        dino.vy = -12;
        dino.jumping = true;
        dino.jumpCooldown = 15;
      }
    }

    function loop(timestamp) {
      if (!canvas || !ctx) {
        console.error("Loop aborted: Canvas or context not available");
        return;
      }
      try {
        console.log("Game loop running");
        const deltaTime = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        update(deltaTime, timestamp);
        draw();
        if (!gameOver) {
          animationFrameId = requestAnimationFrame(loop);
        }
      } catch (error) {
        console.error("Error in game loop:", error);
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        jump();
      }
    });

    document.getElementById("touch-btn").addEventListener("touchstart", (e) => {
      e.preventDefault();
      jump();
    });

    function saveScore(newScore, name) {
      if (!database) {
        console.error("Database not initialized, cannot save score.");
        document.getElementById("final-score").textContent = `Final Score: ${score} (Failed to save)`;
        return;
      }
      const scoreRef = ref(database, "scores");
      push(scoreRef, {
        name: name || "Anonymous",
        score: newScore,
        timestamp: Date.now()
      }).then(() => {
        console.log("Score saved successfully");
      }).catch((error) => {
        console.error("Error saving score:", error);
        document.getElementById("final-score").textContent = `Final Score: ${score} (Failed to save)`;
      });
    }

    function showLeaderboard() {
      const list = document.getElementById("scores");
      if (!database) {
        console.error("Database not initialized, cannot show leaderboard.");
        list.innerHTML = "<li>Leaderboard unavailable. Playing offline.</li>";
        return;
      }
      try {
        const scoreRef = query(ref(database, "scores"), orderByChild("score"), limitToLast(10));
        onValue(scoreRef, (snapshot) => {
          console.log("Leaderboard data received");
          list.innerHTML = "";
          const scores = [];
          snapshot.forEach((child) => {
            scores.push(child.val());
          });
          if (scores.length === 0) {
            list.innerHTML = "<li>No scores yet.</li>";
            return;
          }
          scores.reverse().forEach((entry, i) => {
            const li = document.createElement("li");
            li.textContent = `#${i + 1}: ${entry.name} ‚Äì ${entry.score}`;
            list.appendChild(li);
          });
        }, (error) => {
          console.error("Error updating leaderboard:", error);
          list.innerHTML = `<li>Failed to load leaderboard: ${error.message}</li>`;
        });
      } catch (error) {
        console.error("Error in showLeaderboard:", error);
        list.innerHTML = `<li>Failed to load leaderboard: ${error.message}</li>`;
      }
    }

    function startGame() {
      try {
        console.log("Starting game...");
        const input = document.getElementById("nickname");
        if (!input) {
          console.error("Nickname input not found");
          return;
        }
        nickname = input.value.trim().slice(0, 20).replace(/[<>&]/g, "");
        nickname = nickname || "Anonymous";
        localStorage.setItem("dinoNickname", nickname);
        const form = document.getElementById("nickname-form");
        if (form) {
          form.style.display = "none";
        } else {
          console.error("Nickname form not found");
        }

        // Start game loop
        if (canvas && ctx) {
          console.log("Starting game loop");
          animationFrameId = requestAnimationFrame(loop);
        } else {
          console.error("Cannot start game: Canvas or context not available");
        }

        // Load leaderboard asynchronously
        setTimeout(() => {
          console.log("Loading leaderboard...");
          showLeaderboard();
        }, 0);
      } catch (error) {
        console.error("Error in startGame:", error);
      }
    }

    function restartGame() {
      try {
        console.log("Restarting game...");
        score = 0;
        gameSpeed = 6;
        gameOver = false;
        obstacles = [];
        powerUps = [];
        hasShield = false;
        dino.y = canvas ? canvas.height - 20 : 230;
        dino.vy = 0;
        dino.jumping = false;
        dino.jumpCooldown = 0;
        lastObstacleSpawn = 0;
        const gameOverDiv = document.getElementById("game-over");
        if (gameOverDiv) {
          gameOverDiv.classList.remove("show");
        }
        const touchBtn = document.getElementById("touch-btn");
        if (touchBtn) {
          touchBtn.style.display = "block";
        }
        if (canvas && ctx) {
          animationFrameId = requestAnimationFrame(loop);
        } else {
          console.error("Cannot restart game: Canvas or context not available");
        }
      } catch (error) {
        console.error("Error in restartGame:", error);
      }
    }

    window.onload = () => {
      try {
        console.log("Window loaded");
        const savedName = localStorage.getItem("dinoNickname");
        if (savedName) {
          nickname = savedName;
          const form = document.getElementById("nickname-form");
          if (form) {
            form.style.display = "none";
          }
          setTimeout(() => {
            showLeaderboard();
          }, 0);
          if (canvas && ctx) {
            animationFrameId = requestAnimationFrame(loop);
          } else {
            console.error("Cannot start game on load: Canvas or context not available");
          }
        } else {
          const form = document.getElementById("nickname-form");
          if (form) {
            form.style.display = "flex";
          }
        }
      } catch (error) {
        console.error("Error in window.onload:", error);
      }
    };
  </script>
</body>
</html>